The design is based on having a server and a client file. The client file handle managing the clients (individually) meaning that the code on the clients side should be code which only makes sense to be on the client side such as a input and output. Because we want items to be able to printed and read in a more streamline fashion, we used two threaded classes: input and output. Each one implementing a form of threads so that input and output could be ran at the same time and have less opporunities to block/interfere with one another. The server class is meant to manage the clients in a way which access input from the input threads and pushes messages to the output threads in the client class. They are via a set of user threads which have unique user threads meaning no duplicates. There is also a set of unique usernames so that we can add/removed from it when a client connects and disconects. There is one more data structured used globally and that is a hashmap of usernames to userthreads. Having this alone would very much be sufficent thus the removal of the other two sets, but we chose this option due to accessing needs and separation in some uses. The map is only used for wanting to use a username to retrieve a userthread so that they can send PM to one other. The userthread is so that the server can hold multiple clients all running alongside one another. The class holds the client object, server object and a printwriter. We included several different helper methods in the server class and user thread class to make the code seem more readable and modular. 

In the beginning we all worked on initial design then decided on how to divide up roles. We all believe that the client side would take less rigging and left that to one person while the server side got two people to work on it since it handled more in terms of management. I mostly worked on the server side with Sean. We both shouldered equal amounts of effort into design and implentation of the server and user thread classes. The last contributons I made were to the cleaning up & finalization of the code before submission. 

The way we worked/communicated were via meeting in person and knocking out the design and code. We meet a couple times during the afternoons and simply pair programmed it. We discussed ideas, drew models on board, and helped each other work through the code implentation in person. We decided working on it in person would lead to fast/easier design and implentation. 